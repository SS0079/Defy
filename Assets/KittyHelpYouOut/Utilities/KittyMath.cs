using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = System.Random;

namespace KittyHelpYouOut
{
    public static class KittyMath
    {
        public static Quaternion Damp(Quaternion a, Quaternion b, float lambda, float dt)
        {
            return Quaternion.Slerp(a, b, 1 - Mathf.Exp(-lambda * dt));
        }
        public static  Quaternion Damp(Vector3 a,Vector3 b,float lambda,float dt)
        {
            Quaternion x = Quaternion.Euler(a.x, a.y, a.z);
            Quaternion y = Quaternion.Euler(b.x, b.y, b.z);
            return Quaternion.Slerp(x, y, 1 - Mathf.Exp(-lambda * dt));
        }
        /// <summary>
        /// 返回参数的符号，0则返回0
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public static float SignWithZero(float i)
        {
            if (i>0)
            {
                return 1;
            }else if (i<0)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
        public static Vector3 V3Mean(Vector3[] vs)
        {
            Vector3 mv = Vector3.zero;
            foreach (Vector3 v in vs)
            {
                mv += v;
            }
            return mv / (float)vs.Length;
        }

        public static Vector3 V3Mean(List<Vector3> vs)
        {
            Vector3 mv = Vector3.zero;
            foreach (Vector3 v in vs)
            {
                mv += v;
            }
            return mv / (float)vs.Count;
        }

        public static Vector3 V3Mean(Vector3 v1, Vector3 v2)
        {

            return v1 + v2 / 2f;
        }

        public static float Kmh2Ms(float kmh)
        {
            return kmh * 1000f / 3600f;
        }
        public static float Ms2Kmh(float ms)
        {
            return ms * 3600f / 1000f;
        }
        public static Vector3 OutputInspectorEuler(Transform trans, bool isGlobal = true)
        {
            Vector3 angle;
            if (isGlobal)
            {
                angle = trans.eulerAngles;
            }
            else
            {
                angle = trans.localEulerAngles;
            }
            float x = angle.x;
            float y = angle.y;
            float z = angle.z;

            if (Vector3.Dot(trans.up, Vector3.up) >= 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = angle.x - 360f;
                }
            }
            if (Vector3.Dot(trans.up, Vector3.up) < 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = 180 - angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = 180 - angle.x;
                }
            }

            if (angle.y > 180)
            {
                y = angle.y - 360f;
            }

            if (angle.z > 180)
            {
                z = angle.z - 360f;
            }

            return new Vector3(x, y, z);
        }
        
        public static Vector3 OutputInspectorEuler(Quaternion rotation,Vector3 up)
        {
            Vector3 angle=rotation.eulerAngles;
            float x = angle.x;
            float y = angle.y;
            float z = angle.z;

            if (Vector3.Dot(up, Vector3.up) >= 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = angle.x - 360f;
                }
            }
            if (Vector3.Dot(up, Vector3.up) < 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = 180 - angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = 180 - angle.x;
                }
            }

            if (angle.y > 180)
            {
                y = angle.y - 360f;
            }

            if (angle.z > 180)
            {
                z = angle.z - 360f;
            }

            return new Vector3(x, y, z);
        }
        
        public static float CalculatePitchG(Transform transform, Vector3 localVelocity, float pitchRateDeg)
        {
            // Angular velocity is in radians per second.
            var pitchRate = pitchRateDeg * Mathf.Deg2Rad;

            // If there is no angular velocity in the pitch, then there's no force generated by a turn.
            // Return only the planet's gravity as it would be felt in the vertical.
            if (Mathf.Abs(pitchRate) < Mathf.Epsilon)
                return transform.up.y;

            // Local pitch velocity (X) is positive when pitching down.

            // Radius of turn = velocity / angular velocity
            float radius = localVelocity.z / pitchRate;

            // The radius of the turn will be negative when in a pitching down turn.

            // Force is mass * radius * angular velocity^2
            float verticalForce = (localVelocity.z * localVelocity.z) / radius;

            // Express in G
            float verticalG = -verticalForce / 9.8f;

            // Add the planet's gravity in. When the up is facing directly up, then the full
            // force of gravity will be felt in the vertical.
            verticalG += transform.up.y;

            return verticalG;
        }
        
        public static void KDShuffle<T>(ref T[] array)
        {
            Random r = new Random();
            for (int i = array.Length - 1; i > 0; i--)
            {
                int randomIndex = r.Next(0, i + 1);
                (array[randomIndex], array[i]) = (array[i], array[randomIndex]);
            }
        }
    }
}
